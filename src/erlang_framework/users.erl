-module(users).
-export([user/1, awaitJSON/1]).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% User process (data scientist)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

user(Cloud_Pid) ->
% The user process reads JSON files, which are generated by the
% front-end. Subsequently, those JSON files are processed; relevant data
% is sent to the server process.
% In addition, the user process receives results from the server process
% and writes the output to files.
%
% (Right now there is only 1 user)

  receive

  % data from parsed JSON
  {assignment, Type, ID, Header, Assignment} ->
    io:format("User received data from awaitJSON(): ~p~n",
              [{Type, Header, Assignment}]),
    % send to server
    io:format("Sent to cloud...~n", []),
    {cl0ud, Cloud_Pid} !
      {assignment, self(), Type, ID, Header, Assignment};

  % results from server
  {results, Type, ID, Header, Data} ->
    io:format("Received result from cloud: ~p ~n",
              [{Type, ID, Header, Data}]),
    % example:
    % {"Measurement", {1,1510238735000,"MeasurementTest","..."}, 1.0}
    {Time, Name, Description} = Header,

    % write JSON
    % TODO: add timestamp?
    %Data_ = hd(io_lib:format("~.2f", [Data])),
    Result =
      case Type of
        "FedAvg" ->
          utils:model_to_json(Data);
        "COOP" ->
          utils:model_to_json(Data);
        "FSVRG" ->
          utils:model_to_json(Data);
        _ ->
          Data
      end,
    Vals = [{"type"        , Type       },
            {"data"        , Result     },
            {"id"          , ID         },
            {"name"        , Name       },
            {"descriptions", Description},
            {"time"        , Time       }],

    JSON = mochijson:encode({struct, Vals}),
    ResultFile = "state/user_in/final_result.json",
    ok = file:write_file(ResultFile, JSON),
    io:format("Final results written to ~s ~n", [ResultFile])

  end,
  % TODO: wait a few seconds
  user(Cloud_Pid).


% monitors directory 'state/user_out' for unprocessed JSON files
% this is a spawned process that is kept alive indefinitely long
awaitJSON(User_Pid) ->

  Filename = "state/user_out/assignment.json",

  % check if file exists
  case file:read_file(Filename) of

  {ok, Data} ->
    io:format("Raw: ~p~n", [Data]),
    {_, Xs}    = mochijson:decode(Data),
    io:format("Decoded: ~p~n", [Xs]),

    % delete file after reading
    % (Python module does NOT delete any files)
    file:delete(Filename),

    Type            = proplists:get_value("type"             , Xs),
    ID              = proplists:get_value("id"               , Xs),
    Timestamp       = proplists:get_value("timestamp"        , Xs),
    Name            = proplists:get_value("name"             , Xs),
    Description     = proplists:get_value("description"      , Xs),

    % assignment_config is specified in a nested property list
    {_, Assignment} = proplists:get_value("assignment_config", Xs),

    % TODO
    % probably good idea to turn N > 1 into N consecutive assignments
    % Right now N is ignored
    %_N = proplists:get_value("num_reports", Assignment),

    Header          = {Timestamp, Name, Description},

    % send data to 'user' process
    User_Pid ! {assignment, Type, ID, Header, Assignment};

  {error, _} ->
    no_assignment

  end,
  timer:sleep(3000),
  awaitJSON(User_Pid).

